/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   main.cpp
 * Author: invitado
 *
 * Created on 25 de mayo de 2017, 10:48 AM
 */

#include <cstdio>
#include <string>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;

// Estructura que representa un proceso
// Nombre, hora inicio y hora final
struct proceso{
    string nombreProceso; // El nombre del proceso
    int horaInicio, horaFinal; // La hora de incio y final del proceso
    // Constructor de la estructura
    proceso(){
        horaInicio =  horaFinal  = 0;
        nombreProceso.clear();
    }//Fin constructor
};// Fin estructura

int numeroDeProcesos; // Valor que representa la cantidad de procesos
vector <proceso> procesos;// Vector que contiene todos los procesos a manejar

bool intersectan(vector<bool> &vectorSolucion,int indice){
    for (int i = 0; i < vectorSolucion.size(); i++){
        if (vectorSolucion[i] == 0) continue;
        if (procesos[indice].horaInicio >= procesos[i].horaInicio && procesos[indice].horaInicio < procesos[i].horaFinal) return true;
        if (procesos[indice].horaFinal > procesos[i].horaInicio && procesos[indice].horaFinal <= procesos[i].horaFinal ) return true;
        if (procesos[indice].horaInicio == procesos[i].horaInicio && procesos[indice].horaFinal == procesos[i].horaFinal) return true;
    }
    return false;
}

int contarSolucion(vector<bool> &vectorRespuesta){
    int aux = 0;
    for (int i = 0; i < numeroDeProcesos; i++){
        aux += vectorRespuesta[i] == 1 ? procesos[i].horaFinal - procesos[i].horaInicio : 0; 
    }
    return aux;
}

vector<bool> encontrarSolucion(vector<bool> vectorSolucion, int indice){
    if (indice >= numeroDeProcesos) return vectorSolucion;
    vector<bool> p1(numeroDeProcesos), p2(numeroDeProcesos);
    p1 = encontrarSolucion(vectorSolucion, indice + 1);
    if(!intersectan(vectorSolucion,indice)){
        vectorSolucion[indice] = 1;
        p2 = encontrarSolucion(vectorSolucion,indice + 1);
    }
    else {
        p2 = vectorSolucion;
    }
    return contarSolucion(p1) >= contarSolucion(p2) ? p1 : p2;
}

vector<bool> solucion(){
    vector<bool> p1, p2, aux1;
    aux1.assign(numeroDeProcesos,0);
    p1 = encontrarSolucion(aux1, 1);
    aux1[0] = 1;
    p2 = encontrarSolucion(aux1, 1);
    return contarSolucion(p1) >= contarSolucion(p2) ? p1 : p2;
}

int main(int argc, char** argv) {
    freopen("inp","r",stdin);
    int maximoTiempoOcupado;
    maximoTiempoOcupado = 0;// Variable que representa el tiempo m√°ximo que se ha ocupado una sala
    scanf("%d", &numeroDeProcesos);// Leemos la cantidad de procesos
    procesos.resize(numeroDeProcesos);// Vector que contiene los procesos a analizar
    
    // for lectura de datos
    for (int i = 0; i < numeroDeProcesos; i++){
        cin >> procesos[i].nombreProceso >>  procesos[i].horaInicio >> procesos[i].horaFinal;
    }//fin lectura de datos
    //for (int i = 0; i < numeroDeProcesos; i++) printf("NOMBRE: %s HORA INICIO: %d HORA FINAL %d\n", procesos[i].nombreProceso.c_str(), procesos[i].horaInicio, procesos[i].horaFinal);
    vector<bool> respuesta;
    respuesta.assign(numeroDeProcesos,0);
    respuesta = solucion();
    int cantidadUnos = 0;
    for (int i = 0; i < numeroDeProcesos; i++) cantidadUnos += (int)respuesta[i];
    printf("%d\n", cantidadUnos);
    int tiempoEfectivo = contarSolucion(respuesta);
    printf("%d:%d\n", tiempoEfectivo / 100, tiempoEfectivo % 100);
    for (int i = 0; i < numeroDeProcesos; i++){
        if( respuesta[i] == 1) printf("%s\n", procesos[i].nombreProceso.c_str());
    }
    return 0;
}// fin main

